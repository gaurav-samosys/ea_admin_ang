import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, } from '@angular/core';
import { isValidHex } from 'ngx-color';
let CompactFieldsComponent = class CompactFieldsComponent {
    constructor() {
        this.onChange = new EventEmitter();
        this.HEXWrap = {
            marginTop: '-3px',
            marginBottom: '-3px',
            // flex: '6 1 0%',
            position: 'relative',
        };
        this.HEXinput = {
            width: '80%',
            padding: '0px',
            paddingLeft: '20%',
            border: 'none',
            outline: 'none',
            background: 'none',
            fontSize: '12px',
            color: '#333',
            height: '16px',
        };
        this.HEXlabel = {
            display: 'none',
        };
        this.RGBwrap = {
            marginTop: '-3px',
            marginBottom: '-3px',
            // flex: '3 1 0%',
            position: 'relative',
        };
        this.RGBinput = {
            width: '80%',
            padding: '0px',
            paddingLeft: '30%',
            border: 'none',
            outline: 'none',
            background: 'none',
            fontSize: '12px',
            color: '#333',
            height: '16px',
        };
        this.RGBlabel = {
            position: 'absolute',
            top: '6px',
            left: '0px',
            'line-height': '16px',
            'text-transform': 'uppercase',
            fontSize: '12px',
            color: '#999',
        };
    }
    handleChange({ data, $event }) {
        if (data.hex) {
            if (isValidHex(data.hex)) {
                this.onChange.emit({
                    data: {
                        hex: data.hex,
                        source: 'hex',
                    },
                    $event,
                });
            }
        }
        else {
            this.onChange.emit({
                data: {
                    r: data.r || this.rgb.r,
                    g: data.g || this.rgb.g,
                    b: data.b || this.rgb.b,
                    source: 'rgb',
                },
                $event,
            });
        }
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], CompactFieldsComponent.prototype, "hex", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], CompactFieldsComponent.prototype, "rgb", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", Object)
], CompactFieldsComponent.prototype, "onChange", void 0);
CompactFieldsComponent = tslib_1.__decorate([
    Component({
        selector: 'color-compact-fields',
        template: `
  <div class="compact-fields">
    <div class="compact-active" [style.background]="hex"></div>
    <color-editable-input
      style="flex: 6 1 0%;"
      [style]="{ wrap: HEXWrap, input: HEXinput, label: HEXlabel }"
      label="hex"
      [value]="hex"
      (onChange)="handleChange($event)"
    ></color-editable-input>
    <color-editable-input
      style="flex: 3 1 0%"
      [style]="{ wrap: RGBwrap, input: RGBinput, label: RGBlabel }"
      label="r"
      [value]="rgb.r"
      (onChange)="handleChange($event)"
    ></color-editable-input>
    <color-editable-input
      style="flex: 3 1 0%"
      [style]="{ wrap: RGBwrap, input: RGBinput, label: RGBlabel }"
      label="g"
      [value]="rgb.g"
      (onChange)="handleChange($event)"
    ></color-editable-input>
    <color-editable-input
      style="flex: 3 1 0%"
      [style]="{ wrap: RGBwrap, input: RGBinput, label: RGBlabel }"
      label="b"
      [value]="rgb.b"
      (onChange)="handleChange($event)"
    ></color-editable-input>
  </div>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush,
        preserveWhitespaces: false,
        styles: [`
  .compact-fields {
    display: flex;
    padding-bottom: 6px;
    padding-right: 5px;
    position: relative;
  }
  .compact-active {
    position: absolute;
    top: 6px;
    left: 5px;
    height: 9px;
    width: 9px;
  }
  `]
    })
], CompactFieldsComponent);
export { CompactFieldsComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGFjdC1maWVsZHMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWNvbG9yL2NvbXBhY3QvIiwic291cmNlcyI6WyJjb21wYWN0LWZpZWxkcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxVQUFVLEVBQVEsTUFBTSxXQUFXLENBQUM7QUF5RDdDLElBQWEsc0JBQXNCLEdBQW5DLE1BQWEsc0JBQXNCO0lBdkRuQztRQTBEWSxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUM3QyxZQUFPLEdBQTRCO1lBQ2pDLFNBQVMsRUFBRSxNQUFNO1lBQ2pCLFlBQVksRUFBRSxNQUFNO1lBQ3BCLGtCQUFrQjtZQUNsQixRQUFRLEVBQUUsVUFBVTtTQUNyQixDQUFDO1FBQ0YsYUFBUSxHQUE0QjtZQUNsQyxLQUFLLEVBQUUsS0FBSztZQUNaLE9BQU8sRUFBRSxLQUFLO1lBQ2QsV0FBVyxFQUFFLEtBQUs7WUFDbEIsTUFBTSxFQUFFLE1BQU07WUFDZCxPQUFPLEVBQUUsTUFBTTtZQUNmLFVBQVUsRUFBRSxNQUFNO1lBQ2xCLFFBQVEsRUFBRSxNQUFNO1lBQ2hCLEtBQUssRUFBRSxNQUFNO1lBQ2IsTUFBTSxFQUFFLE1BQU07U0FDZixDQUFDO1FBQ0YsYUFBUSxHQUE0QjtZQUNsQyxPQUFPLEVBQUUsTUFBTTtTQUNoQixDQUFDO1FBQ0YsWUFBTyxHQUE0QjtZQUNqQyxTQUFTLEVBQUUsTUFBTTtZQUNqQixZQUFZLEVBQUUsTUFBTTtZQUNwQixrQkFBa0I7WUFDbEIsUUFBUSxFQUFFLFVBQVU7U0FDckIsQ0FBQztRQUNGLGFBQVEsR0FBNEI7WUFDbEMsS0FBSyxFQUFFLEtBQUs7WUFDWixPQUFPLEVBQUUsS0FBSztZQUNkLFdBQVcsRUFBRSxLQUFLO1lBQ2xCLE1BQU0sRUFBRSxNQUFNO1lBQ2QsT0FBTyxFQUFFLE1BQU07WUFDZixVQUFVLEVBQUUsTUFBTTtZQUNsQixRQUFRLEVBQUUsTUFBTTtZQUNoQixLQUFLLEVBQUUsTUFBTTtZQUNiLE1BQU0sRUFBRSxNQUFNO1NBQ2YsQ0FBQztRQUNGLGFBQVEsR0FBNEI7WUFDbEMsUUFBUSxFQUFFLFVBQVU7WUFDcEIsR0FBRyxFQUFFLEtBQUs7WUFDVixJQUFJLEVBQUUsS0FBSztZQUNYLGFBQWEsRUFBRSxNQUFNO1lBQ3JCLGdCQUFnQixFQUFFLFdBQVc7WUFDN0IsUUFBUSxFQUFFLE1BQU07WUFDaEIsS0FBSyxFQUFFLE1BQU07U0FDZCxDQUFDO0lBeUJKLENBQUM7SUF2QkMsWUFBWSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDWixJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO29CQUNqQixJQUFJLEVBQUU7d0JBQ0osR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO3dCQUNiLE1BQU0sRUFBRSxLQUFLO3FCQUNkO29CQUNELE1BQU07aUJBQ1AsQ0FBQyxDQUFDO2FBQ0o7U0FDRjthQUFNO1lBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pCLElBQUksRUFBRTtvQkFDSixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3ZCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDdkIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN2QixNQUFNLEVBQUUsS0FBSztpQkFDZDtnQkFDRCxNQUFNO2FBQ1AsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0NBQ0YsQ0FBQTtBQXpFVTtJQUFSLEtBQUssRUFBRTs7bURBQWE7QUFDWjtJQUFSLEtBQUssRUFBRTs7bURBQVc7QUFDVDtJQUFULE1BQU0sRUFBRTs7d0RBQW9DO0FBSGxDLHNCQUFzQjtJQXZEbEMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLHNCQUFzQjtRQUNoQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBZ0NUO1FBa0JELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1FBQy9DLG1CQUFtQixFQUFFLEtBQUs7aUJBakJ4Qjs7Ozs7Ozs7Ozs7Ozs7R0FjRDtLQUlGLENBQUM7R0FDVyxzQkFBc0IsQ0EwRWxDO1NBMUVZLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGlzVmFsaWRIZXgsIFJHQkEgfSBmcm9tICduZ3gtY29sb3InO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1jb21wYWN0LWZpZWxkcycsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJjb21wYWN0LWZpZWxkc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJjb21wYWN0LWFjdGl2ZVwiIFtzdHlsZS5iYWNrZ3JvdW5kXT1cImhleFwiPjwvZGl2PlxuICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgc3R5bGU9XCJmbGV4OiA2IDEgMCU7XCJcbiAgICAgIFtzdHlsZV09XCJ7IHdyYXA6IEhFWFdyYXAsIGlucHV0OiBIRVhpbnB1dCwgbGFiZWw6IEhFWGxhYmVsIH1cIlxuICAgICAgbGFiZWw9XCJoZXhcIlxuICAgICAgW3ZhbHVlXT1cImhleFwiXG4gICAgICAob25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgc3R5bGU9XCJmbGV4OiAzIDEgMCVcIlxuICAgICAgW3N0eWxlXT1cInsgd3JhcDogUkdCd3JhcCwgaW5wdXQ6IFJHQmlucHV0LCBsYWJlbDogUkdCbGFiZWwgfVwiXG4gICAgICBsYWJlbD1cInJcIlxuICAgICAgW3ZhbHVlXT1cInJnYi5yXCJcbiAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgPjwvY29sb3ItZWRpdGFibGUtaW5wdXQ+XG4gICAgPGNvbG9yLWVkaXRhYmxlLWlucHV0XG4gICAgICBzdHlsZT1cImZsZXg6IDMgMSAwJVwiXG4gICAgICBbc3R5bGVdPVwieyB3cmFwOiBSR0J3cmFwLCBpbnB1dDogUkdCaW5wdXQsIGxhYmVsOiBSR0JsYWJlbCB9XCJcbiAgICAgIGxhYmVsPVwiZ1wiXG4gICAgICBbdmFsdWVdPVwicmdiLmdcIlxuICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIHN0eWxlPVwiZmxleDogMyAxIDAlXCJcbiAgICAgIFtzdHlsZV09XCJ7IHdyYXA6IFJHQndyYXAsIGlucHV0OiBSR0JpbnB1dCwgbGFiZWw6IFJHQmxhYmVsIH1cIlxuICAgICAgbGFiZWw9XCJiXCJcbiAgICAgIFt2YWx1ZV09XCJyZ2IuYlwiXG4gICAgICAob25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAuY29tcGFjdC1maWVsZHMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcGFkZGluZy1ib3R0b206IDZweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gIC5jb21wYWN0LWFjdGl2ZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNnB4O1xuICAgIGxlZnQ6IDVweDtcbiAgICBoZWlnaHQ6IDlweDtcbiAgICB3aWR0aDogOXB4O1xuICB9XG4gIGAsXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbn0pXG5leHBvcnQgY2xhc3MgQ29tcGFjdEZpZWxkc0NvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGhleDogc3RyaW5nO1xuICBASW5wdXQoKSByZ2I6IFJHQkE7XG4gIEBPdXRwdXQoKSBvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBIRVhXcmFwOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgICBtYXJnaW5Ub3A6ICctM3B4JyxcbiAgICBtYXJnaW5Cb3R0b206ICctM3B4JyxcbiAgICAvLyBmbGV4OiAnNiAxIDAlJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgfTtcbiAgSEVYaW5wdXQ6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAgIHdpZHRoOiAnODAlJyxcbiAgICBwYWRkaW5nOiAnMHB4JyxcbiAgICBwYWRkaW5nTGVmdDogJzIwJScsXG4gICAgYm9yZGVyOiAnbm9uZScsXG4gICAgb3V0bGluZTogJ25vbmUnLFxuICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICBmb250U2l6ZTogJzEycHgnLFxuICAgIGNvbG9yOiAnIzMzMycsXG4gICAgaGVpZ2h0OiAnMTZweCcsXG4gIH07XG4gIEhFWGxhYmVsOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgICBkaXNwbGF5OiAnbm9uZScsXG4gIH07XG4gIFJHQndyYXA6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAgIG1hcmdpblRvcDogJy0zcHgnLFxuICAgIG1hcmdpbkJvdHRvbTogJy0zcHgnLFxuICAgIC8vIGZsZXg6ICczIDEgMCUnLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICB9O1xuICBSR0JpbnB1dDoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICAgd2lkdGg6ICc4MCUnLFxuICAgIHBhZGRpbmc6ICcwcHgnLFxuICAgIHBhZGRpbmdMZWZ0OiAnMzAlJyxcbiAgICBib3JkZXI6ICdub25lJyxcbiAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgY29sb3I6ICcjMzMzJyxcbiAgICBoZWlnaHQ6ICcxNnB4JyxcbiAgfTtcbiAgUkdCbGFiZWw6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzZweCcsXG4gICAgbGVmdDogJzBweCcsXG4gICAgJ2xpbmUtaGVpZ2h0JzogJzE2cHgnLFxuICAgICd0ZXh0LXRyYW5zZm9ybSc6ICd1cHBlcmNhc2UnLFxuICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgY29sb3I6ICcjOTk5JyxcbiAgfTtcblxuICBoYW5kbGVDaGFuZ2UoeyBkYXRhLCAkZXZlbnQgfSkge1xuICAgIGlmIChkYXRhLmhleCkge1xuICAgICAgaWYgKGlzVmFsaWRIZXgoZGF0YS5oZXgpKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaGV4OiBkYXRhLmhleCxcbiAgICAgICAgICAgIHNvdXJjZTogJ2hleCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAkZXZlbnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcjogZGF0YS5yIHx8IHRoaXMucmdiLnIsXG4gICAgICAgICAgZzogZGF0YS5nIHx8IHRoaXMucmdiLmcsXG4gICAgICAgICAgYjogZGF0YS5iIHx8IHRoaXMucmdiLmIsXG4gICAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgICAgfSxcbiAgICAgICAgJGV2ZW50LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iXX0=